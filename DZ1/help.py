
# 1. Stack (Стек)
# Описание:

# Стек — это структура данных, которая работает по принципу "последним пришёл — первым вышел" (LIFO, Last In First Out).
# Представьте стек тарелок: последняя поставленная сверху тарелка будет снята первой.
# Основные операции:

# push(x): Добавление элемента x на вершину стека.
# pop(): Удаление и возврат элемента с вершины стека.
# peek(): Просмотр элемента на вершине стека без удаления.
# isEmpty(): Проверка, пуст ли стек.
# Пример:

stack = []
stack.append(1)  # push 1
stack.append(2)  # push 2
print(stack.pop())  # pop, выводит 2
print(stack.pop())  # pop, выводит 1
print(len(stack))  # Выведет количество элементов в списке(стеке)

# 2. Queue (Очередь)
# Описание:

# Очередь — это структура данных, которая работает по принципу "первым пришёл — первым вышел" (FIFO, First In First Out).
# Представьте очередь людей в магазине: первый пришедший человек будет обслужен первым.
# Основные операции:

# enqueue(x): Добавление элемента x в конец очереди.
# dequeue(): Удаление и возврат элемента из начала очереди.
# front(): Просмотр элемента в начале очереди без удаления.
# isEmpty(): Проверка, пуста ли очередь.
# Пример:

from collections import deque
queue = deque()
queue.append(1)  # enqueue 1
queue.append(2)  # enqueue 2
print(queue.popleft())  # dequeue, выводит 1
print(queue.popleft())  # dequeue, выводит 2

# 3. Deque (Двусторонняя очередь)
# Описание:

# Двусторонняя очередь (deque) позволяет добавлять и удалять элементы с обоих концов.
# Это гибридная структура, которая объединяет возможности стека и очереди.
# Основные операции:

# append(x): Добавление элемента x в конец deque.
# appendleft(x): Добавление элемента x в начало deque.
# pop(): Удаление и возврат элемента из конца deque.
# popleft(): Удаление и возврат элемента из начала deque.
# Пример:

deque = deque()
deque.append(1)  # Добавление в конец
deque.appendleft(2)  # Добавление в начало
print(deque.pop())  # Удаление из конца, выводит 1
print(deque.popleft())  # Удаление из начала, выводит 2

# 4. List (Список)

# Список (list) — это упорядоченная коллекция элементов, доступ к которым осуществляется по индексу.
# В Python списки реализованы как динамические массивы.
# Основные операции:

# append(x): Добавление элемента x в конец списка.
# insert(i, x): Вставка элемента x на позицию i.
# remove(x): Удаление первого вхождения элемента x.
# pop(i): Удаление и возврат элемента на позиции i.
# Пример:

lst = [1, 2, 3]
lst.append(4)  # Добавление 4 в конец
lst.insert(1, 5)  # Вставка 5 на позицию 1
lst.remove(2)  # Удаление первого вхождения 2
print(lst.pop(0))  # Удаление и возврат элемента на позиции 0, выводит 1

# 5. Hash Table (Хеш-таблица)

# Хеш-таблица — это структура данных, которая реализует ассоциативный массив, т.е. коллекцию пар "ключ-значение".
# Элементы размещаются на основе вычисления хеш-функции от ключа, что обеспечивает быстрый доступ к значению по ключу.
# Основные операции:

# put(key, value): Добавление или обновление пары "ключ-значение".
# get(key): Получение значения по ключу.
# remove(key): Удаление пары "ключ-значение" по ключу.
# containsKey(key): Проверка, содержится ли ключ в таблице.
# Пример:

hash_table = {}
hash_table['apple'] = 1  # put
hash_table['banana'] = 2  # put
print(hash_table['apple'])  # get, выводит 1
hash_table.pop('apple')  # remove
print('apple' in hash_table)  # containsKey, выводит False

# Основные отличия и примеры использования

# Stack: Используется для выполнения задач обратного отсчёта, реализация алгоритма поиска в глубину, отмена операций в текстовых редакторах.

# Queue: Используется для задач планирования, реализация алгоритма поиска в ширину, управление очередями на печать.

# Deque: Используется для задач, требующих эффективного добавления и удаления элементов с обоих концов, например,
#  реализация буферов с кольцевой структурой.

# List: Универсальная структура данных для хранения упорядоченных коллекций элементов, поддерживающая произвольный доступ.

# Hash Table: Используется для задач, требующих быстрого доступа к данным по ключу, например, реализация словарей, кэширование.

# Эти структуры данных играют ключевую роль в разработке программного обеспечения, предоставляя различные способы организации 
# и управления данными в зависимости от требований конкретной задачи.



# Пузырьковая сортировка: Простая, но неэффективная для больших массивов, так как имеет время выполнения O(n^2).

# Сортировка вставками: Более эффективна для почти отсортированных массивов, имеет время выполнения O(n^2) в худшем случае,
#  но O(n) в лучшем случае (если массив уже отсортирован).

# Оба алгоритма просты для понимания и реализации, но не подходят для сортировки больших массивов из-за своей неэффективности по времени.


# Линейный поиск (Linear Search)
# Описание:
# Линейный поиск — это самый простой алгоритм поиска, который проверяет каждый элемент в списке последовательно,
#  пока не найдёт целевой элемент или не закончится список.

# Принцип работы:

# Начать с первого элемента списка.
# Проверять каждый элемент один за другим.
# Если элемент найден, вернуть его индекс.
# Если элемент не найден после проверки всех элементов, вернуть -1.


# Бинарный поиск (Binary Search)
# Описание:
# Бинарный поиск — это более эффективный алгоритм поиска, который работает на отсортированном массиве.
#  Он многократно делит массив пополам, сравнивая целевой элемент со средним элементом и отбрасывая половину массива на каждом шаге.

# Принцип работы:

# Определить середину массива.
# Сравнить целевой элемент с элементом в середине.
# Если элемент найден, вернуть его индекс.
# Если целевой элемент меньше среднего, повторить поиск в левой половине массива.
# Если целевой элемент больше среднего, повторить поиск в правой половине массива.
# Повторять шаги 1-5 до тех пор, пока элемент не будет найден или диапазон поиска не станет пустым.


# Выводы
# Линейный поиск:

# Время выполнения: O(n) в худшем случае.
# Прост в реализации.
# Используется для небольших или неотсортированных массивов.
# Бинарный поиск:

# Время выполнения: O(log n) в худшем случае.
# Требует отсортированного массива.
# Значительно быстрее линейного поиска для больших массивов.
# Оба алгоритма имеют свои применения, и выбор между ними зависит от размера массива и состояния его отсортированности.


# Stack, Queue и Deque: Эти структуры данных не предназначены для доступа к произвольным элементам и
#  поэтому имеют линейную сложность для таких операций.

# List: Доступ и запись по индексу выполняются за постоянное время, что делает списки эффективными для задач, требующих произвольного доступа.

# Hash Table: Обеспечивает очень быстрый доступ и запись по ключу в среднем случае,
#  но может иметь линейную сложность в худшем случае из-за коллизий.


# 1. Строки (String, Str)
# Строки представляют собой последовательность символов, заключенную в кавычки (одинарные, двойные или тройные).
# Строки являются неизменяемыми (immutable), то есть их содержимое нельзя изменить после создания.

# s = "Hello, World!"

# 2. Байты (Byte)
# Тип данных bytes представляет собой неизменяемую последовательность байтов. Он используется для хранения двоичных данных,
# таких как изображения или файлы.

# b = b'hello'  # или bytes('hello', 'utf-8')

# 3. Массив байтов (Bytearray)

# Тип bytearray представляет собой изменяемую последовательность байтов. Он позволяет изменять содержимое после создания.

# ba = bytearray(b'hello')
# ba[0] = ord('H')

# 4. Целые числа (Int)

# Тип int представляет собой целые числа, положительные или отрицательные, без десятичных знаков.
# В Python нет ограничения на размер целого числа.

# x = 42

# 5. Числа с плавающей точкой (Float)

# Тип float представляет собой числа с плавающей точкой, то есть числа с десятичными знаками.

# y = 3.14159

# 6. Логические значения (Boolean)

# Тип bool имеет два значения: True и False. Логические значения часто используются в условных операторах и циклах.

# flag = True

# 7. Словари (Dict)

# Тип dict представляет собой коллекцию пар "ключ-значение". Ключи должны быть уникальными и неизменяемыми (например, строки, числа),
# а значения могут быть любого типа.

# person = {'name': 'Alice', 'age': 25}

# 8. Списки (List)

# Тип list представляет собой упорядоченную изменяемую коллекцию элементов. Элементы списка могут быть любого типа,
# и один список может содержать элементы разных типов.

# fruits = ['apple', 'banana', 'cherry']

# 9. Кортежи (Tuple)

# Тип tuple представляет собой упорядоченную неизменяемую коллекцию элементов.
# Как и списки, кортежи могут содержать элементы разных типов.

# point = (2, 3)

# 10. Множества (Set)

# Тип set представляет собой неупорядоченную коллекцию уникальных элементов. Множества используются для операций над множествами,
# таких как объединение и пересечение.

# numbers = {1, 2, 3, 4, 5}

# Свойства типов данных:

# Тип данных	Изменяемость	Упорядоченность 	Пример использования
# str	            Нет	              Да	         Текстовые данные
# bytes	            Нет	              Да	          Двоичные данные
# bytearray	        Да	              Да	          Двоичные данные
# int	            Нет	              Нет	            Целые числа
# float	            Нет	              Нет	           Дробные числа
# bool	            Нет	              Нет	         Логические значения
# dict	            Да	              Нет	     Коллекция пар "ключ-значение"
# list	            Да	              Да	   Упорядоченная коллекция элементов
# tuple	            Нет	              Да	   Упорядоченная неизменяемая коллекция
# set	            Да	              Нет	Неупорядоченная коллекция уникальных элементов

# Основные операции:

# Строки (String, Str)

# Конкатенация: s1 + s2
# Индексация: s[0]
# Срезы: s[1:3]
# Методы: s.upper(), s.lower(), s.split()

# Байты (Byte) и Массив байтов (Bytearray)

# Индексация: b[0]
# Срезы: b[1:3]
# Методы: b.decode('utf-8')

# Целые числа (Int) и Числа с плавающей точкой (Float)

# Арифметические операции: +, -, *, /, ** (степень)
# Логические значения (Boolean)
# Логические операции: and, or, not

# Словари (Dict)

# Доступ по ключу: d['key']
# Добавление/обновление элемента: d['key'] = value
# Методы: d.keys(), d.values(), d.items()

# Списки (List)

# Индексация: lst[0]
# Срезы: lst[1:3]
# Методы: lst.append(), lst.remove(), lst.sort()

# Кортежи (Tuple)

# Индексация: t[0]
# Срезы: t[1:3]
# Методы: t.count(), t.index()

# Множества (Set)

# Добавление элемента: s.add()
# Удаление элемента: s.remove()
# Операции: s.union(), s.intersection(), s.difference()


#                      Временная сложность операций (Big O) для Dict, List, Tuple, Set

# Понимание временной сложности различных операций с основными структурами данных в Python важно для написания эффективного кода.
# Рассмотрим каждый тип данных:

# 1. Словарь (Dict)

# Чтение (доступ к элементу по ключу): O(1) в среднем случае, O(n) в худшем случае из-за возможных коллизий хеш-функций.
# Запись (вставка или обновление элемента по ключу): O(1) в среднем случае, O(n) в худшем случае из-за возможных коллизий хеш-функций.
# Словари реализованы как хеш-таблицы, что позволяет получать доступ, вставлять и удалять элементы за среднее константное время.

# d = {'a': 1, 'b': 2, 'c': 3}
# value = d['a']          # Чтение
# d['d'] = 4              # Запись

# 2. Список (List)

# Чтение (доступ к элементу по индексу): O(1)
# Запись (обновление элемента по индексу): O(1)

# Добавление элемента в конец: O(1) амортизированное, из-за возможного увеличения размера списка.
# Вставка или удаление элемента в начале или в середине: O(n) из-за необходимости сдвига элементов.
# Списки являются динамическими массивами, предоставляющими константное время для индексации и обновлений,
# но линейное время для вставок и удалений, требующих сдвига элементов.

# lst = [1, 2, 3, 4]
# value = lst[2]          # Чтение
# lst[2] = 5              # Запись
# lst.append(6)           # Добавление
# lst.insert(1, 7)        # Вставка
# lst.pop(1)              # Удаление

# 3. Кортеж (Tuple)

# Чтение (доступ к элементу по индексу): O(1)
# Запись (обновление элемента): Не применимо, так как кортежи неизменяемы.
# Кортежи похожи на списки, но являются неизменяемыми, то есть их элементы нельзя изменить после создания. 
# Это приводит к константному времени для чтения элементов, но отсутствует операция записи.

# t = (1, 2, 3, 4)
# value = t[2]            # Чтение
# # t[2] = 5              # Запись (не применимо)

# 4. Множество (Set)

# Чтение (проверка на наличие элемента): O(1) в среднем случае, O(n) в худшем случае из-за возможных коллизий хеш-функций.
# Запись (вставка элемента): O(1) в среднем случае, O(n) в худшем случае из-за возможных коллизий хеш-функций.
# Множества также реализованы как хеш-таблицы, что позволяет выполнять операции проверки наличия и вставки элементов за среднее константное время.

# s = {1, 2, 3, 4}
# exists = 3 in s         # Чтение
# s.add(5)                # Запись

# Таблица временной сложности

# Структура данных	  Операция	                 Временная сложность
# Dict	              Чтение	            O(1) в среднем, O(n) в худшем
# Dict	              Запись	            O(1) в среднем, O(n) в худшем
# List	              Чтение(по индексу)	          O(1)
# List	              Запись(по индексу)	          O(1)
# List	            Добавление в конец	       O(1) амортизированное
# List	            Вставка/Удаление	              O(n)
# Tuple	            Чтение(по индексу)	              O(1)
# Tuple	            Запись	                      Не применимо
# Set	            Чтение(проверка элемента)	O(1) в среднем, O(n) в худшем
# Set	            Запись (вставка элемента)	O(1) в среднем, O(n) в худшем


# Компрехеншены (comprehensions) в Python — это мощный и лаконичный способ создания и манипуляции коллекциями.
# Они позволяют создавать новые списки, множества и словари из существующих последовательностей за одну строку кода,
# что делает его более читабельным и эффективным.

# Списковые компрехеншены (List Comprehensions)
# Списковые компрехеншены используются для создания нового списка из существующего, 
# применяя выражение или фильтр к каждому элементу исходного списка.

# Пример 1: Создание списка квадратов чисел

# # Без списковых компрехеншенов
# squares = []
# for x in range(10):
#     squares.append(x**2)

# # Со списковыми компрехеншенами
# squares = [x**2 for x in range(10)]
# print(squares)

# Пример 2: Создание списка четных чисел

# # Без списковых компрехеншенов
# evens = []
# for x in range(10):
#     if x % 2 == 0:
#         evens.append(x)

# # Со списковыми компрехеншенами
# evens = [x for x in range(10) if x % 2 == 0]
# print(evens)

# Сетевые компрехеншены (Set Comprehensions)

# Сетевые компрехеншены работают аналогично списковым, но создают множества. Они полезны для удаления дубликатов 
# и автоматической сортировки элементов.

# Пример 3: Создание множества квадратов чисел

# # Без сетевых компрехеншенов
# squares = set()
# for x in range(10):
#     squares.add(x**2)

# # С сетевыми компрехеншенами
# squares = {x**2 for x in range(10)}
# print(squares)

# Пример 4: Создание множества четных чисел

# # Без сетевых компрехеншенов
# evens = set()
# for x in range(10):
#     if x % 2 == 0:
#         evens.add(x)

# # С сетевыми компрехеншенами
# evens = {x for x in range(10) if x % 2 == 0}
# print(evens)

# Словарные компрехеншены (Dict Comprehensions)

# Словарные компрехеншены используются для создания нового словаря, применяя выражение к ключам 
# и/или значениям исходного словаря или другой итерации.

# Пример 5: Создание словаря квадратов чисел

# # Без словарных компрехеншенов
# squares = {}
# for x in range(10):
#     squares[x] = x**2

# # Со словарными компрехеншенами
# squares = {x: x**2 for x in range(10)}
# print(squares)

# Пример 6: Создание словаря четных чисел и их квадратов

# # Без словарных компрехеншенов
# evens = {}
# for x in range(10):
#     if x % 2 == 0:
#         evens[x] = x**2

# # Со словарными компрехеншенами
# evens = {x: x**2 for x in range(10) if x % 2 == 0}
# print(evens)

# Краткий обзор синтаксиса

# List Comprehension

# [expression for item in iterable if condition]

# Set Comprehension

# {expression for item in iterable if condition}

# Dict Comprehension

# {key_expression: value_expression for item in iterable if condition}

# Примеры комбинированного использования

# Пример 7: Создание списка квадратов чисел, умноженных на 2

# squares_times_two = [x**2 * 2 for x in range(10)]
# print(squares_times_two)

# Пример 8: Создание множества уникальных первых букв в строках списка

# words = ["apple", "banana", "cherry", "date", "elderberry"]
# first_letters = {word[0] for word in words}
# print(first_letters)

# Пример 9: Создание словаря из списка кортежей

# pairs = [('a', 1), ('b', 2), ('c', 3)]
# pair_dict = {key: value for key, value in pairs}
# print(pair_dict)

# Использование компрехеншенов позволяет писать более короткий и читабельный код, 
# что делает его предпочтительным инструментом для многих операций с коллекциями в Python.


#                                      Изменяемые типы данных

# Изменяемые типы данных позволяют изменять их содержимое после создания. Это значит, что можно добавлять, 
# удалять или изменять элементы без создания нового объекта.

# Примеры изменяемых типов данных

# Список (List)

# Списки могут изменяться после создания: добавление, удаление и изменение элементов.

# lst = [1, 2, 3]
# lst.append(4)  # Добавление элемента
# lst[0] = 0    # Изменение элемента
# print(lst)    # [0, 2, 3, 4]

# Словарь (Dict)

# В словарях можно изменять значения по ключам, добавлять новые пары ключ-значение и удалять существующие.

# d = {'a': 1, 'b': 2}
# d['c'] = 3  # Добавление пары ключ-значение
# d['a'] = 0  # Изменение значения по ключу
# print(d)    # {'a': 0, 'b': 2, 'c': 3}

# Множество (Set)

# Множества позволяют добавлять и удалять элементы.

# s = {1, 2, 3}
# s.add(4)   # Добавление элемента
# s.remove(1)  # Удаление элемента
# print(s)    # {2, 3, 4}

# Массив (bytearray)

# Массивы байт позволяют изменять отдельные байты.

# b = bytearray(b"hello")
# b[0] = ord('H')  # Изменение байта
# print(b)        # bytearray(b'Hello')

#                                         Неизменяемые типы данных

# Неизменяемые типы данных не могут быть изменены после создания. Любая операция, изменяющая объект, создаёт новый объект.

# Примеры неизменяемых типов данных

# Строка (str)

# Строки неизменяемы; любые операции, которые изменяют строку, создают новую строку.

# s = "hello"
# s = s.replace("h", "H")  # Создание новой строки
# print(s)  # "Hello"

# Кортеж (tuple)

# Кортежи неизменяемы; нельзя изменить их элементы после создания.

# t = (1, 2, 3)
# # t[0] = 0  # Это вызовет ошибку
# t = (0,) + t[1:]  # Создание нового кортежа
# print(t)  # (0, 2, 3)

# Числа (int, float, complex)

# Числа неизменяемы; любые операции над числами создают новые объекты.

# x = 5
# x = x + 1  # Создание нового объекта
# print(x)   # 6

# Массив байтов (bytes)

# Массивы байтов неизменяемы; любые операции создают новый объект.

# b = b"hello"
# b = b.replace(b"h", b"H")  # Создание нового объекта
# print(b)  # b"Hello"

# frozenset

# Неизменяемая версия множества.

# fs = frozenset([1, 2, 3])
# # fs.add(4)  # Это вызовет ошибку

# Преимущества и недостатки

#     Изменяемые типы

# Преимущества:

# Более гибкие: можно изменять содержимое без создания новых объектов.
# Экономия памяти при большом числе изменений.
# Недостатки:

# Может привести к ошибкам при неосторожном использовании (например, случайное изменение содержимого).
# Не могут быть использованы в качестве ключей словарей или элементов множеств.

#     Неизменяемые типы

# Преимущества:

# Безопаснее: исключают возможность случайного изменения данных.
# Могут быть использованы в качестве ключей словарей или элементов множеств.

# Недостатки:

# Меньшая гибкость: каждое изменение требует создания нового объекта.
# Может быть менее эффективно при большом числе изменений.


# Хэшируемые типы данных в Python

# В Python хэшируемость данных означает, что объекты могут быть использованы в 
# качестве ключей в словарях (dict) или элементов в множествах (set). Хэшируемость объекта определяется наличием 
# у него неизменяемого хэш-значения, которое вычисляется с помощью встроенной функции hash().

# Условия хэшируемости

# Неизменяемость: Если объект изменяется, его хэш-значение должно оставаться постоянным.
# Это условие делает большинство неизменяемых типов данных хэшируемыми.
# Реализация метода __hash__ и __eq__: Объекты должны реализовывать метод __hash__, возвращающий их хэш-значение,
# и метод __eq__, определяющий, когда два объекта равны.

# Хэшируемые типы данных

# 1. Числа (int, float, complex)
# Все числовые типы данных в Python хэшируемы, поскольку они неизменяемы.

# print(hash(42))       # int
# print(hash(3.14))     # float
# print(hash(1 + 2j))   # complex

# 2. Строки (str)
# Строки неизменяемы, поэтому они хэшируемы и могут быть использованы в качестве ключей в словарях.

# print(hash("hello"))

# 3. Кортежи (tuple)
# Кортежи неизменяемы и хэшируемы, но только если все их элементы также хэшируемы.

# print(hash((1, 2, 3)))
# Кортежи с нехэшируемыми элементами (например, списками) не хэшируемы.
# print(hash((1, [2, 3])))  # Это вызовет ошибку

# 4. frozenset
# Неизменяемая версия множества. Все элементы во frozenset должны быть хэшируемыми.

# fs = frozenset([1, 2, 3])
# print(hash(fs))

# Нехэшируемые типы данных

# 1. Списки (list)
# Списки изменяемы, поэтому они не хэшируемы и не могут быть использованы в качестве ключей в словарях или элементов в множествах.

# print(hash([1, 2, 3]))  # Это вызовет ошибку

# 2. Словари (dict)
# Словари изменяемы и не хэшируемы. Они не могут быть использованы в качестве ключей или элементов множества.

# print(hash({'a': 1, 'b': 2}))  # Это вызовет ошибку

# 3. Множества (set)
# Множества изменяемы, поэтому они не хэшируемы и не могут быть использованы в качестве ключей или элементов множества.

# print(hash({1, 2, 3}))  # Это вызовет ошибку

# Примеры использования

# Хэшируемые объекты часто используются в качестве ключей в словарях или элементов в множествах.

# # Пример использования хэшируемых объектов в словаре
# d = {
#     42: "int",
#     3.14: "float",
#     (1, 2, 3): "tuple",
#     "hello": "string",
#     frozenset([1, 2, 3]): "frozenset"
# }

# # Пример использования хэшируемых объектов в множестве
# s = {42, 3.14, (1, 2, 3), "hello", frozenset([1, 2, 3])}
# print(d)
# print(s)

# Заключение

# Хэшируемость объектов важна для их использования в ключевых структурах данных Python, таких как словари и множества.
# Изменяемые объекты, такие как списки и словари, не могут быть хэшируемыми, в то время как неизменяемые объекты,
# такие как числа, строки, кортежи и frozenset, обычно хэшируемы и могут использоваться в этих структурах данных.






